<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Azure Resources</title>
    <link rel="stylesheet" href="styles.css"> <!-- Optional: link to an external CSS file for styling -->
</head>
<body>
    <header>
        <h1>Welcome to React Resources</h1>
    </header>
    
    <section>
        <h2>Event Handling</h2>
        <p>
            In React, event handling is achieved through JSX event attributes, similar to HTML event attributes in JavaScript. 
            For example, the click event handling attribute is:
            - In JSX: <code>onClick</code>
            - In JavaScript: <code>onclick</code>
        </p>

        <p>
            When you assign <code>onClick={handleClick}</code>, you are passing the function itself as a reference. 
            React will then call this function when the click event occurs. However, if you use <code>onClick={handleClick()}</code>, 
            the function <code>handleClick</code> is executed immediately, and its return value (which is often <code>undefined</code> if 
            the function doesn't explicitly return anything) is assigned to the <code>onClick</code> handler. This leads to the function running 
            on every render and not when the button is clicked.
        </p>

        <p>
            Sample code:
            <pre>
                <code>
function MyComponent() {
  const handleClick = () => {
    console.log('Button was clicked!');
  };

  return (
    <button onClick={handleClick}> {/* Correct way */}
      Click me
    </button>
  );
}
                </code>
            </pre>
        </p>
        <p>
            <h3> how to embed expressions in string</h3>
            The symbol ` is called a backtick or grave accent. In JSX (and JavaScript in general), it is used to define template literals.
            Template literals allow you to embed expressions within strings. 
            
            Here's how it works:
            <pre> //  preformatted text. It preserves both spaces and line breaks exactly as they are written in the HTML code.
                <code> // this is add inline code  or a fragment of computer code. it displays monospaced font to differentiate it from normal text
                    let randomNum = 5;
                    let userInput = 3;

                    let message = `Computer number: ${randomNum}, Your guess: ${userInput}`;
                    console.log(message); 
                </code>
            </pre> // ideal for display code example in readable format
            here to embed randonNumber and userInput expressions we used backtick. 
        </p>

        <h3>Please refer following link to see various ways to declare React functions</h3>
        <a href="Reactfunctiondeclarations.html" target="_blank"> Various React Functional Declarations </a>
        <a href="https://legacy.reactjs.org/docs/handling-events.html#gatsby-focus-wrapper" target="_blank"> Handling functions react class components </a>
        <p>             
                <a href="https://legacy.reactjs.org/docs/jsx-in-depth.html#javascript-expressions-as-children" target="_blank"> JavaScript Expressions as Children
                </a>
                <a href="https://legacy.reactjs.org/docs/jsx-in-depth.html#javascript-expressions-as-props" target="_blank"> JavaScript Expressions as Props
                </a>
                <a href="https://legacy.reactjs.org/docs/events.html#gatsby-focus-wrapper " target="_blank"> Supported Events
                </a>
                <a href="https://legacy.reactjs.org/docs/events.html#supported-events" target="_blank"> Synthetic Events
                </a>
            <p>

        </p>
    </section>
    <section>
        declaration of state in react.
        usestate allows component to have its own state
        <pre>
            <code>
        import {useState} from React;
        const LightSwitch = () => {
            const [lightOn, setLightOn] = useState(false);
            function handleLight () {
                setLightOn(!lightOn)
            }

            return(
                <h1> Light is turned on: {lightOn}</h1>
                <button onClick={ () => {setLightOn(!lightOn)}}</button> > or
                <button onClick={ handleLight } ></button>
            )
        }

     </code>
    </pre>
    </section>
    <section>
        Run the following command to create the React app named counter_app: 
        <p>
            npx create-react-app counter_app
        </p>
    </section>
    <section>
       <h3> Managing state in react </h3> 
       with in using usestate
       if its across we can manage through global state  which is called useContext
    </section>
    <section>
        <p>
            prop drilling is a situation where you are passing data from a parent to a child component, then to a grandchild component, and so on, until it reaches a more distant component further down the component tree, where this data is required
        </p>
    </section>
    <section>
        <h3> React Navigation </h3>
         <p>
            npx create-react-app counter_app
        </p>
       <section>
        <h3> traditional app navigation</h3>
        scenario - 1
        Before the advent of modern JavaScript frameworks, most websites were implemented as multi-page applications. That is, when a user clicks on a link, the browser navigates to a new webpage, sends a request to the web server; this then responds with the full webpage and the new page is displayed in the browser.
        This can make your application resource intensive to the Web Server. CPU time is spent rendering dynamic pages and network bandwidth is used sending entire webpages back for every request. If your website is complex, it may appear slow to your users, even slower if they have a slow or limited internet connection.

        scenario -2 
        You have a web application that has a navigation bar on top and two pages. One page shows the latest news, and the other shows the current user’s profile page. The navigation bar contains a link for each page.
        In a traditional website, when the user clicks the Profile link, the web browser sends the request to the web server. The web server generates the HTML page and sends it back to the web browser. The web browser then renders the new web page.

        To solve this problem, many web developers develop their web applications as Single Page Applications.
       </section>
       <section>
        <h3>Single page navigation </h3>
        scenario -1
        Youre using many Single Page Applications every day. Think of your favorite social network, or online email provider, or the map application you use to find local businesses. Their excellent user experiences are driven by Single Page Applications.
        A Single Page Application allows the user to interact with the website without downloading entire new webpages. Instead, it rewrites the current webpage as the user interacts with it. The outcome is that the application will feel faster and more responsive to the user.
       
        scenario - 2
        In a Single Page Application, different pages are broken into templates (or views). Each view will have HTML code containing variables that can be updated by the application.
        The web browser sends the request to the web server, and the web server sends back a JSON object. The web browser then updates the web page by inserting the template with the variables replaced by the values in the JSON object.    
    </section>
    <section>
        <h3>Anchor Tag Elements in Single-Page Elements</h3>
        <p>
            A single-page application can’t have regular anchor tag elements as a traditional web app can. 
            The reason for this is that the default behavior of an anchor tag is to load another HTML file from a server and refresh the page. This page refresh is not possible in a SPA that's powered by a library such as React because a total page refresh is not the way that a SPA works, as explained earlier in this lesson item. 
            Instead, a SPA comes with its own special implementation of anchor tags and links, which only give an illusion of loading different pages to the end user when in fact, they simply load different components into a single element of the real DOM into which the virtual DOM tree gets mounted and updated.   
        </p>
    </section>
    </section>
    <footer>
       
    </footer>
</body>
</html>
